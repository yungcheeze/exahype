// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#ifndef __GRMHDSolver_FV_Variables_CLASS_HEADER__
#define __GRMHDSolver_FV_Variables_CLASS_HEADER__

#include "AbstractGRMHDSolver_FV.h"

#include <algorithm>

#include "tarch/la/Matrix.h"

/**
 * Positions of fields in the vector of unkonwns.
 *
 * With these constants, you can write Q[g11], Q[K22] and Q[B33] instead of
 * Q[0], Q[9] and Q[34]. Your code is meaningful in terms of physics while
 * you still access on a C-array level.
 *
 * You might want to use a typedef to shorten the notation or create 
 * an instance of this class.
 **/
class GRMHD::AbstractGRMHDSolver_FV::VariableShortcuts {
public:
  static constexpr int _Q[] = { 0, 1, 4, 5, 8, 9, 10, 13, -1 };

  static constexpr int    rho = 0;
  static constexpr int    vel = 1;
  static constexpr int      E = 4;
  static constexpr int      B = 5;
  static constexpr int    psi = 8;
  static constexpr int  lapse = 9;
  static constexpr int  shift = 10;
  static constexpr int    gij = 13;


  static const int* asArray() { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableShortcuts

/**
 * Variable names as strings as given in the toolkit.
 * 
 * These names might want to be used for plotting, output, etc.
 *
 **/
class GRMHD::AbstractGRMHDSolver_FV::VariableNames {
public:
  static constexpr char const *_Q[] = { "rho", "vel", "E", "B", "psi", "lapse", "shift", "gij", nullptr };

  static constexpr char const *   rho = "rho";
  static constexpr char const *   vel = "vel";
  static constexpr char const *     E = "E";
  static constexpr char const *     B = "B";
  static constexpr char const *   psi = "psi";
  static constexpr char const * lapse = "lapse";
  static constexpr char const * shift = "shift";
  static constexpr char const *   gij = "gij";


  static const char* const* asArray() { return _Q; } // type: whatever
  const char* operator [] (int index) const { return _Q[index]; }
  const char* operator () (int index) const { return _Q[index]; }
}; // end of VariableNames

/*
 * NEW CLASS IDEA:
 * 
 * class ....::VariablePointers {
 *   private:   double* Q;
 *   public:
 *      double &varfoo;
 *      double &varbar;
 *      VariablePointers(double*Q) : varfoo(Q[0]), bar(Q[1]), ... {}
 * }
 * 
 * Advantages: Use as positions in Q.
 *
 */


class GRMHD::AbstractGRMHDSolver_FV::ReadOnlyVariables {
  private:
    const double* const _Q;
  public:
    static constexpr int SizeVariables  = 19;
    static constexpr int SizeParameters = 0;
    static constexpr int Size           = 19+0;
    
    ReadOnlyVariables(const double* const Q) : _Q(Q) {}
    
    double operator [] (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double operator () (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    const double* data() const {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }
    

    double rho() const { return _Q[0]; }

    double vel(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[1+index];
    }

    tarch::la::Vector<3,double> vel() const {
      tarch::la::Vector<3,double> values;
      values=_Q[1],_Q[2],_Q[3];
      return values;
    }

    double E() const { return _Q[4]; }

    double B(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[5+index];
    }

    tarch::la::Vector<3,double> B() const {
      tarch::la::Vector<3,double> values;
      values=_Q[5],_Q[6],_Q[7];
      return values;
    }

    double psi() const { return _Q[8]; }

    double lapse() const { return _Q[9]; }

    double shift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[10+index];
    }

    tarch::la::Vector<3,double> shift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[10],_Q[11],_Q[12];
      return values;
    }

    double gij(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[13+index];
    }

    tarch::la::Vector<6,double> gij() const {
      tarch::la::Vector<6,double> values;
      values=_Q[13],_Q[14],_Q[15],_Q[16],_Q[17],_Q[18];
      return values;
    }


}; // end of ReadOnlyVariables


class GRMHD::AbstractGRMHDSolver_FV::Variables {
  private:
    double* _Q;
  public:
    static constexpr int SizeVariables  = 19;
    static constexpr int SizeParameters = 0;
    static constexpr int Size           = 19+0;
  
    Variables(double* Q) : _Q(Q) {}
    
    void operator = (Variables& variables) {
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    void operator = (ReadOnlyVariables& variables) {
      assertion(variables.variables()==SizeVariables);
      assertion(variables.parameters()==SizeParameters);
      assertion(variables.size()==Size);
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    double& operator [] (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double& operator () (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double* data() {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }
    

    double rho() const { return _Q[0]; }

    double vel(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[1+index];
    }

    tarch::la::Vector<3,double> vel() const {
      tarch::la::Vector<3,double> values;
      values=_Q[1],_Q[2],_Q[3];
      return values;
    }

    double E() const { return _Q[4]; }

    double B(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[5+index];
    }

    tarch::la::Vector<3,double> B() const {
      tarch::la::Vector<3,double> values;
      values=_Q[5],_Q[6],_Q[7];
      return values;
    }

    double psi() const { return _Q[8]; }

    double lapse() const { return _Q[9]; }

    double shift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[10+index];
    }

    tarch::la::Vector<3,double> shift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[10],_Q[11],_Q[12];
      return values;
    }

    double gij(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[13+index];
    }

    tarch::la::Vector<6,double> gij() const {
      tarch::la::Vector<6,double> values;
      values=_Q[13],_Q[14],_Q[15],_Q[16],_Q[17],_Q[18];
      return values;
    }



    double& rho() { return _Q[0]; }

    double& vel(int index) { return _Q[1+index]; }

    void vel(const tarch::la::Vector<3,double>& values) {
      *(_Q+1)=values[0];
      *(_Q+2)=values[1];
      *(_Q+3)=values[2];
    }

    void vel(double vel0,double vel1,double vel2) {
      *(_Q+1)=vel0;
      *(_Q+2)=vel1;
      *(_Q+3)=vel2;
    }

    double& E() { return _Q[4]; }

    double& B(int index) { return _Q[5+index]; }

    void B(const tarch::la::Vector<3,double>& values) {
      *(_Q+5)=values[0];
      *(_Q+6)=values[1];
      *(_Q+7)=values[2];
    }

    void B(double B0,double B1,double B2) {
      *(_Q+5)=B0;
      *(_Q+6)=B1;
      *(_Q+7)=B2;
    }

    double& psi() { return _Q[8]; }

    double& lapse() { return _Q[9]; }

    double& shift(int index) { return _Q[10+index]; }

    void shift(const tarch::la::Vector<3,double>& values) {
      *(_Q+10)=values[0];
      *(_Q+11)=values[1];
      *(_Q+12)=values[2];
    }

    void shift(double shift0,double shift1,double shift2) {
      *(_Q+10)=shift0;
      *(_Q+11)=shift1;
      *(_Q+12)=shift2;
    }

    double& gij(int index) { return _Q[13+index]; }

    void gij(const tarch::la::Vector<6,double>& values) {
      *(_Q+13)=values[0];
      *(_Q+14)=values[1];
      *(_Q+15)=values[2];
      *(_Q+16)=values[3];
      *(_Q+17)=values[4];
      *(_Q+18)=values[5];
    }

    void gij(double gij0,double gij1,double gij2,double gij3,double gij4,double gij5) {
      *(_Q+13)=gij0;
      *(_Q+14)=gij1;
      *(_Q+15)=gij2;
      *(_Q+16)=gij3;
      *(_Q+17)=gij4;
      *(_Q+18)=gij5;
    }


}; // end of Variables


class GRMHD::AbstractGRMHDSolver_FV::Fluxes {
  private:
    double** _F;
  public:
    static constexpr int SizeVariables = 19; 
    static constexpr int Dimensions    = DIMENSIONS;
  
    Fluxes(double** F) : _F(F) {}
    
    /** The rows of the flux tensor. */
    int variables() const {
      return SizeVariables;
    }
    
    /** The columns of the flux tensor. */
    int dimensions() const {
      return Dimensions;
    }
    

    double rho(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][0];
    }

    tarch::la::Vector<DIMENSIONS,double> rho() const {
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][0],_F[1][0]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][0],_F[1][0],_F[2][0]);
      #endif
      return values;
    }

    double vel(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][1+row];
    }

    tarch::la::Vector<DIMENSIONS,double> vel(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][1+row],_F[1][1+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][1+row],_F[1][1+row],_F[2][1+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<3,DIMENSIONS,double> vel() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][1],_F[1][1],
               _F[0][2],_F[1][2],
               _F[0][3],_F[1][3];
      #elif DIMENSIONS==3
      values = _F[0][1],_F[1][1],
               _F[0][2],_F[1][2],
               _F[0][3],_F[1][3];
      #endif
      return values;
    }

    double E(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][4];
    }

    tarch::la::Vector<DIMENSIONS,double> E() const {
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][4],_F[1][4]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][4],_F[1][4],_F[2][4]);
      #endif
      return values;
    }

    double B(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][5+row];
    }

    tarch::la::Vector<DIMENSIONS,double> B(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][5+row],_F[1][5+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][5+row],_F[1][5+row],_F[2][5+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<3,DIMENSIONS,double> B() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][5],_F[1][5],
               _F[0][6],_F[1][6],
               _F[0][7],_F[1][7];
      #elif DIMENSIONS==3
      values = _F[0][5],_F[1][5],
               _F[0][6],_F[1][6],
               _F[0][7],_F[1][7];
      #endif
      return values;
    }

    double psi(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][8];
    }

    tarch::la::Vector<DIMENSIONS,double> psi() const {
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][8],_F[1][8]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][8],_F[1][8],_F[2][8]);
      #endif
      return values;
    }

    double lapse(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][9];
    }

    tarch::la::Vector<DIMENSIONS,double> lapse() const {
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][9],_F[1][9]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][9],_F[1][9],_F[2][9]);
      #endif
      return values;
    }

    double shift(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][10+row];
    }

    tarch::la::Vector<DIMENSIONS,double> shift(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][10+row],_F[1][10+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][10+row],_F[1][10+row],_F[2][10+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<3,DIMENSIONS,double> shift() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][10],_F[1][10],
               _F[0][11],_F[1][11],
               _F[0][12],_F[1][12];
      #elif DIMENSIONS==3
      values = _F[0][10],_F[1][10],
               _F[0][11],_F[1][11],
               _F[0][12],_F[1][12];
      #endif
      return values;
    }

    double gij(int row, int column) const {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][13+row];
    }

    tarch::la::Vector<DIMENSIONS,double> gij(int row) const {
      assertion(row >= 0 && row<6);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][13+row],_F[1][13+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][13+row],_F[1][13+row],_F[2][13+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<6,DIMENSIONS,double> gij() const {
      tarch::la::Matrix<6,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][13],_F[1][13],
               _F[0][14],_F[1][14],
               _F[0][15],_F[1][15],
               _F[0][16],_F[1][16],
               _F[0][17],_F[1][17],
               _F[0][18],_F[1][18];
      #elif DIMENSIONS==3
      values = _F[0][13],_F[1][13],
               _F[0][14],_F[1][14],
               _F[0][15],_F[1][15],
               _F[0][16],_F[1][16],
               _F[0][17],_F[1][17],
               _F[0][18],_F[1][18];
      #endif
      return values;
    }



    double& rho(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][0];
    }

    void rho(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][0]=values[0];
      _F[1][0]=values[1];
      #if DIMENSIONS==3
      _F[2][0]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void rho(const tarch::la::Vector<3,double>& values) {
      _F[0][0]=values[0];
      _F[1][0]=values[1];
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void rho(double v0,double v1,double v2) {
      _F[0][0]=v0;
      _F[1][0]=v1;
      #if DIMENSIONS==3
      _F[2][0]=v2;
      #endif
    }
    #if DIMENSIONS==2
    void rho(double v0,double v1) {
      _F[0][0]=v0;
      _F[1][0]=v1;
    }
    #endif

    double& vel(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][1+row];
    }

    void vel(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][1+row]=values[0];
      _F[1][1+row]=values[1];
      #if DIMENSIONS==2
      _F[2][1+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void vel(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][1+row]=values[0];
      _F[1][1+row]=values[1];
    }
    #endif

    void vel(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][1]=values(0,0);
      _F[0][2]=values(1,0);
      _F[0][3]=values(2,0);
      _F[1][1]=values(0,1);
      _F[1][2]=values(1,1);
      _F[1][3]=values(2,1);
      #if DIMENSIONS==3
      _F[2][1]=values(0,2);
      _F[2][2]=values(1,2);
      _F[2][3]=values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void vel(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][1]=values(0,0);
      _F[0][2]=values(1,0);
      _F[0][3]=values(2,0);
      _F[1][1]=values(0,1);
      _F[1][2]=values(1,1);
      _F[1][3]=values(2,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void vel(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][1+row]=v0;
      _F[1][1+row]=v1;
      #if DIMENSIONS==3
      _F[2][1+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void vel(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][1+row]=v0;
      _F[1][1+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void vel(double v00, double v01, double v02,
             double v10, double v11, double v12,
             double v20, double v21, double v22) {
      _F[0][1]=v00;
      _F[0][2]=v10;
      _F[0][3]=v20;
      _F[1][1]=v01;
      _F[1][2]=v11;
      _F[1][3]=v21;
      #if DIMENSIONS==3
      _F[2][1]=v02;
      _F[2][2]=v12;
      _F[2][3]=v22;
      #endif
    }
    #if DIMENSIONS==2
    void vel(double v00, double v01,
             double v10, double v11,
             double v20, double v21) {
      _F[0][1]=v00;
      _F[0][2]=v10;
      _F[0][3]=v20;
      _F[1][1]=v01;
      _F[1][2]=v11;
      _F[1][3]=v21;
    }
    #endif

    double& E(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][4];
    }

    void E(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][4]=values[0];
      _F[1][4]=values[1];
      #if DIMENSIONS==3
      _F[2][4]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void E(const tarch::la::Vector<3,double>& values) {
      _F[0][4]=values[0];
      _F[1][4]=values[1];
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void E(double v0,double v1,double v2) {
      _F[0][4]=v0;
      _F[1][4]=v1;
      #if DIMENSIONS==3
      _F[2][4]=v2;
      #endif
    }
    #if DIMENSIONS==2
    void E(double v0,double v1) {
      _F[0][4]=v0;
      _F[1][4]=v1;
    }
    #endif

    double& B(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][5+row];
    }

    void B(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][5+row]=values[0];
      _F[1][5+row]=values[1];
      #if DIMENSIONS==2
      _F[2][5+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void B(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][5+row]=values[0];
      _F[1][5+row]=values[1];
    }
    #endif

    void B(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][5]=values(0,0);
      _F[0][6]=values(1,0);
      _F[0][7]=values(2,0);
      _F[1][5]=values(0,1);
      _F[1][6]=values(1,1);
      _F[1][7]=values(2,1);
      #if DIMENSIONS==3
      _F[2][5]=values(0,2);
      _F[2][6]=values(1,2);
      _F[2][7]=values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void B(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][5]=values(0,0);
      _F[0][6]=values(1,0);
      _F[0][7]=values(2,0);
      _F[1][5]=values(0,1);
      _F[1][6]=values(1,1);
      _F[1][7]=values(2,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void B(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][5+row]=v0;
      _F[1][5+row]=v1;
      #if DIMENSIONS==3
      _F[2][5+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void B(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][5+row]=v0;
      _F[1][5+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void B(double v00, double v01, double v02,
           double v10, double v11, double v12,
           double v20, double v21, double v22) {
      _F[0][5]=v00;
      _F[0][6]=v10;
      _F[0][7]=v20;
      _F[1][5]=v01;
      _F[1][6]=v11;
      _F[1][7]=v21;
      #if DIMENSIONS==3
      _F[2][5]=v02;
      _F[2][6]=v12;
      _F[2][7]=v22;
      #endif
    }
    #if DIMENSIONS==2
    void B(double v00, double v01,
           double v10, double v11,
           double v20, double v21) {
      _F[0][5]=v00;
      _F[0][6]=v10;
      _F[0][7]=v20;
      _F[1][5]=v01;
      _F[1][6]=v11;
      _F[1][7]=v21;
    }
    #endif

    double& psi(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][8];
    }

    void psi(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][8]=values[0];
      _F[1][8]=values[1];
      #if DIMENSIONS==3
      _F[2][8]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void psi(const tarch::la::Vector<3,double>& values) {
      _F[0][8]=values[0];
      _F[1][8]=values[1];
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void psi(double v0,double v1,double v2) {
      _F[0][8]=v0;
      _F[1][8]=v1;
      #if DIMENSIONS==3
      _F[2][8]=v2;
      #endif
    }
    #if DIMENSIONS==2
    void psi(double v0,double v1) {
      _F[0][8]=v0;
      _F[1][8]=v1;
    }
    #endif

    double& lapse(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][9];
    }

    void lapse(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][9]=values[0];
      _F[1][9]=values[1];
      #if DIMENSIONS==3
      _F[2][9]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void lapse(const tarch::la::Vector<3,double>& values) {
      _F[0][9]=values[0];
      _F[1][9]=values[1];
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void lapse(double v0,double v1,double v2) {
      _F[0][9]=v0;
      _F[1][9]=v1;
      #if DIMENSIONS==3
      _F[2][9]=v2;
      #endif
    }
    #if DIMENSIONS==2
    void lapse(double v0,double v1) {
      _F[0][9]=v0;
      _F[1][9]=v1;
    }
    #endif

    double& shift(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][10+row];
    }

    void shift(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][10+row]=values[0];
      _F[1][10+row]=values[1];
      #if DIMENSIONS==2
      _F[2][10+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void shift(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][10+row]=values[0];
      _F[1][10+row]=values[1];
    }
    #endif

    void shift(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][10]=values(0,0);
      _F[0][11]=values(1,0);
      _F[0][12]=values(2,0);
      _F[1][10]=values(0,1);
      _F[1][11]=values(1,1);
      _F[1][12]=values(2,1);
      #if DIMENSIONS==3
      _F[2][10]=values(0,2);
      _F[2][11]=values(1,2);
      _F[2][12]=values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void shift(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][10]=values(0,0);
      _F[0][11]=values(1,0);
      _F[0][12]=values(2,0);
      _F[1][10]=values(0,1);
      _F[1][11]=values(1,1);
      _F[1][12]=values(2,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void shift(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][10+row]=v0;
      _F[1][10+row]=v1;
      #if DIMENSIONS==3
      _F[2][10+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void shift(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][10+row]=v0;
      _F[1][10+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void shift(double v00, double v01, double v02,
               double v10, double v11, double v12,
               double v20, double v21, double v22) {
      _F[0][10]=v00;
      _F[0][11]=v10;
      _F[0][12]=v20;
      _F[1][10]=v01;
      _F[1][11]=v11;
      _F[1][12]=v21;
      #if DIMENSIONS==3
      _F[2][10]=v02;
      _F[2][11]=v12;
      _F[2][12]=v22;
      #endif
    }
    #if DIMENSIONS==2
    void shift(double v00, double v01,
               double v10, double v11,
               double v20, double v21) {
      _F[0][10]=v00;
      _F[0][11]=v10;
      _F[0][12]=v20;
      _F[1][10]=v01;
      _F[1][11]=v11;
      _F[1][12]=v21;
    }
    #endif

    double& gij(int row, int column) {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][13+row];
    }

    void gij(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<6);
      _F[0][13+row]=values[0];
      _F[1][13+row]=values[1];
      #if DIMENSIONS==2
      _F[2][13+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void gij(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<6);
      _F[0][13+row]=values[0];
      _F[1][13+row]=values[1];
    }
    #endif

    void gij(const tarch::la::Matrix<6,DIMENSIONS,double>& values) {
      _F[0][13]=values(0,0);
      _F[0][14]=values(1,0);
      _F[0][15]=values(2,0);
      _F[0][16]=values(3,0);
      _F[0][17]=values(4,0);
      _F[0][18]=values(5,0);
      _F[1][13]=values(0,1);
      _F[1][14]=values(1,1);
      _F[1][15]=values(2,1);
      _F[1][16]=values(3,1);
      _F[1][17]=values(4,1);
      _F[1][18]=values(5,1);
      #if DIMENSIONS==3
      _F[2][13]=values(0,2);
      _F[2][14]=values(1,2);
      _F[2][15]=values(2,2);
      _F[2][16]=values(3,2);
      _F[2][17]=values(4,2);
      _F[2][18]=values(5,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void gij(const tarch::la::Matrix<6,3,double>& values) {
      _F[0][13]=values(0,0);
      _F[0][14]=values(1,0);
      _F[0][15]=values(2,0);
      _F[0][16]=values(3,0);
      _F[0][17]=values(4,0);
      _F[0][18]=values(5,0);
      _F[1][13]=values(0,1);
      _F[1][14]=values(1,1);
      _F[1][15]=values(2,1);
      _F[1][16]=values(3,1);
      _F[1][17]=values(4,1);
      _F[1][18]=values(5,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void gij(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<6);
      _F[0][13+row]=v0;
      _F[1][13+row]=v1;
      #if DIMENSIONS==3
      _F[2][13+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void gij(int row, double v0,double v1) {
      assertion(row >= 0 && row<6);
      _F[0][13+row]=v0;
      _F[1][13+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void gij(double v00, double v01, double v02,
             double v10, double v11, double v12,
             double v20, double v21, double v22,
             double v30, double v31, double v32,
             double v40, double v41, double v42,
             double v50, double v51, double v52) {
      _F[0][13]=v00;
      _F[0][14]=v10;
      _F[0][15]=v20;
      _F[0][16]=v30;
      _F[0][17]=v40;
      _F[0][18]=v50;
      _F[1][13]=v01;
      _F[1][14]=v11;
      _F[1][15]=v21;
      _F[1][16]=v31;
      _F[1][17]=v41;
      _F[1][18]=v51;
      #if DIMENSIONS==3
      _F[2][13]=v02;
      _F[2][14]=v12;
      _F[2][15]=v22;
      _F[2][16]=v32;
      _F[2][17]=v42;
      _F[2][18]=v52;
      #endif
    }
    #if DIMENSIONS==2
    void gij(double v00, double v01,
             double v10, double v11,
             double v20, double v21,
             double v30, double v31,
             double v40, double v41,
             double v50, double v51) {
      _F[0][13]=v00;
      _F[0][14]=v10;
      _F[0][15]=v20;
      _F[0][16]=v30;
      _F[0][17]=v40;
      _F[0][18]=v50;
      _F[1][13]=v01;
      _F[1][14]=v11;
      _F[1][15]=v21;
      _F[1][16]=v31;
      _F[1][17]=v41;
      _F[1][18]=v51;
    }
    #endif


}; // end of Fluxes

// NamingSchemes:


#endif
